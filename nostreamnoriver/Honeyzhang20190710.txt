最近学习了lora的WOR（Wake_up On Redio 空中唤醒）模式，这种工作模式可最大限度地
降低待机功耗，自己的理解如下：

lora的数据包由：前导码（preamble）+ 报头（header）+ 有效载荷（payload）组成

在发射端发送广播数据的时候，接收端可周期性的唤醒去读取广播数据，接收状态的功耗较高，
在普通的接收模式下，接收模式的时间理论上不能低于读取一整包数据的时间
T = 8 * packet_length / baud_rate 

packet_length = preamble + header + payload 

所以这个时间是由数据包长度决定的，在数据包较长的情况下，接收模式持续的时间需要更长，
为了保证通信成功率，这个时间还要乘以2，为什么？因为在进入接收状态的时候发送端不一定
刚好开始发送数据，接收端要等待这个数据包发送结束，再接收一个完整的数据包，才可以通信
成功，这样会大大增加功耗，而WOR（空中唤醒）则通过增加前导码的方式，使用前导码来触发
接收中断，发送端发送一个时长大于唤醒周期的前导码，保证每发送一个数据包，接收端一定
可以接收到前导码并触发中断，通过前导码来触发接收中断就是WOR的核心所在啦。

重新整理一下工作流程：

接收端1秒唤醒一次，每次唤醒5ms,5ms内接收到前导码则继续等待直至数据接收完毕再进入睡眠
5ms内没有接收到前导码，则直接进入睡眠。这样，在没有数据发来的时候，模块每1秒唤醒5ms，
有数据发来的时候，此次唤醒时间为读取一个数据包的时间。

对比一下前面所说的唤醒方式：

接收端1秒唤醒一次，每次唤醒时间为T = 2 * 8 * packet_length / baud_rate ，以波
特率为19200为例，平均1.2个字节就要1ms，12个字节的数据包（preamble + header + payload），
就要10ms，120个字节监听窗口就需要100ms，WOR模式的监听窗口仍然只需要5ms,这个功耗
就不是一个量级了。

以上就是我对WOR模式的理解，学无止境，keep fighting！